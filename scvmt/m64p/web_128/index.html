<!doctype html>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<html lang="en-us">
  <head>
      <meta charset="utf-8">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>mupen64plus-web Demo</title>
      <style>
            html, body {
                width:  100%;
                height: 100%;
                margin: 0px;
                padding: 0;
                overflow: hidden;
                background-color: #303030;
            }


            .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
            textarea.emscripten {top: 0; left: 100px; width:  50%;height: 15%; position:absolute; border: 0px none; background-color: #00000066;font-family: monospace;color:white;}
            div.emscripten { text-align: center; }
            div.emscripten_border { border: 0px solid black; }
            /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
            canvas.emscripten {top: calc(50vh - (100% / 2));left: calc(50vw - (100% / 2));width:  100%;height: 100%; border: 0px none; background-color: #000000;}

            div.loader {
                position: absolute;
                top: 50%;
                left: 50%;
                margin-top: -25px;
                color:white;
                margin-left: -100px;
            }

            progress[value] {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                border: none;
                width: 250px;
                height: 20px;
                background-color: white;
            }

            .spinner {
                width: 35px;
                display: inline-block;
                background-color: #fcfefd;
                margin: 0px auto;
                height: 35px;

                -webkit-animation: 3s rotate2 ease-in-out infinite;
                animation: 3s flip ease-in-out infinite;
            }

            @-webkit-keyframes flip {
                0% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(0deg);
                }
                25% {
                    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(0deg);
                    transform: perspective(120px) rotateX(-180deg) rotateY(0deg);
                }
                50% {
                    transform: perspective(120px) rotateX(-180deg) rotateY(-180deg);
                    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-180deg);
                }
                75% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(-180deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(-180deg);
                }
                100% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(-360deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(-360deg);
                }
            }

            @keyframes flip {
                0% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(0deg);
                }
                25% {
                    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(0deg);
                    transform: perspective(120px) rotateX(-180deg) rotateY(0deg);
                }
                50% {
                    transform: perspective(120px) rotateX(-180deg) rotateY(-180deg);
                    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-180deg);
                }
                75% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(-180deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(-180deg);
                }
                100% {
                    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(-360deg);
                    transform: perspective(120px) rotateX(0deg) rotateY(-360deg);
                }
            }

        </style>
        <script src="stats.min.js"></script>
    </head>
  <body>
        <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
        <!--<textarea class="emscripten" id="output" rows="8"></textarea>-->
        <div class='fullscreenDiv' id="imloader"><div class="loader">
        <figure style="overflow:visible;" id="spinner"><div class="spinner"></div>
                    <center style="display: inline-block;margin-top:0.5em"><strong><font size="6">LOADING...</font></strong></center><div class="spinner"></div>
        </figure>
        <div class="emscripten" id="status">Downloading...</div>
        <div class="emscripten">
                    <progress value="50" max="100" id="progress" style="visibility: visible;"></progress>  
        </div>
        </div></div>
    <script src="module.js"></script>
    <script>
        
        var canvas = document.getElementById('canvas');
        
        var resize_event = false; //launch once
            var max_fb_size = 4096; //max size of screen
            function onResize() {
				return;
                if (!resize_event) {
                    var element = canvas;
                    resize_event = true;
                    var elementHeight = 0;
                    var elementWidth = 0;
                    setInterval(function () {
                        if (element.scrollHeight !== elementHeight || element.scrollWidth !== elementWidth) {
                            if (!(typeof GLFW === 'undefined')) {
                                elementHeight = element.scrollHeight;
                                elementWidth = element.scrollWidth;
                                if (elementHeight > max_fb_size)
                                    elementHeight = max_fb_size;
                                if (elementWidth > max_fb_size)
                                    elementWidth = max_fb_size;
                                GLFW.onCanvasResize(elementWidth, elementHeight);
                            } else
                                console.log("waiting WASM initialization");
                        }
                    }, 300); //this is not "thread safe", WebGL will lost context randomly(set to lowest timer for test)
                }
            }

            //I dont want to pass "preinit canvas size to WASM from JS"(or have any JS-preinit variables for WASM) better call resize on first frame from wasm
            function resize_glfw_wasm() {
				return;
                var element = canvas;
                var elementHeight = 0;
                var elementWidth = 0;
                elementHeight = element.scrollHeight;
                elementWidth = element.scrollWidth;
                if (elementHeight > max_fb_size)
                    elementHeight = max_fb_size;
                if (elementWidth > max_fb_size)
                    elementWidth = max_fb_size;
                console.log("startup size " + elementWidth + " " + elementHeight);
                if (!(typeof GLFW === 'undefined')) {
                    GLFW.onCanvasResize(elementWidth, elementHeight);
                }

            }
        
        function hidec(c) {
				if(c)
				document.getElementById('stats').style.display="none";
				else
				document.getElementById('stats').style.display="";
                /*if(c)
				document.getElementById('output').style.display="none";
				else
				document.getElementById('output').style.display="";*/
            }
        
        var gcx=true;
            document.addEventListener('keydown', function(event) {
                if (event.code == 'KeyH') {
                     hidec(!gcx);
                     gcx=!gcx;
                    }
                });
    </script>
    <script>
var ASSERTIONS = 0;
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}

// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {String} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}

          var memoryInitializer = 'index.html.mem';
          if (typeof Module['locateFile'] === 'function') {
            memoryInitializer = Module['locateFile'](memoryInitializer);
          } else if (Module['memoryInitializerPrefixURL']) {
            memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
          }
          Module['memoryInitializerRequestURL'] = memoryInitializer;
          var meminitXHR = Module['memoryInitializerRequest'] = new XMLHttpRequest();
          meminitXHR.open('GET', memoryInitializer, true);
          meminitXHR.responseType = 'arraybuffer';
          meminitXHR.send(null);

          var script = document.createElement('script');
          script.src = "index.js";
          document.body.appendChild(script);

</script>
  </body>
</html>
